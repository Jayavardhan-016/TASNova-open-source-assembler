# TASNova-open-source-assembler

This project implements a **modular 40-bit custom processor architecture** in SystemVerilog as part of the **TASNova Architecture**. The system includes an assembler, instruction decoder, ALU, register file, and a processor simulator. It is designed to demonstrate real-world processor pipeline behavior, execute custom instructions, and trace register-level operations.

---

## ðŸ“Œ Project Phases and Structure

### âœ… Phase 1: Assembler Design (Core Project)
**Module**: `assembler.sv`  
The assembler is the central component of this project. It converts human-readable assembly instructions (e.g., `ADD R1, R2`, `MOV R3, #25`) into 40-bit machine instructions.  

- **Instruction Format**:
  - `6 bits` â€“ Opcode
  - `2 bits` â€“ Operand mode
  - `32 bits` â€“ Operands (split into 2 fields)
- **Modes**:
  - `00`: Regâ€“Reg
  - `01`: Regâ€“Imm
  - `10`: Immâ€“Reg
  - `11`: Immâ€“Imm
- **Output**: `output.txt` containing hex-encoded 40-bit instructions.

> ðŸ”¹ This is the **main IP module** â€” all other modules are built to validate and simulate this assembler's output.

---

### âœ… Phase 2: Module Integration for Testing the Assembler

To test the assembler, the following modules are integrated to form a minimal but complete processor environment.

#### ðŸ“¦ `instruction_decoder.sv`
- Reads 40-bit instructions from `output.txt`
- Extracts opcode, mode, and two 16-bit operands
- Supports all 4 operand modes and zero-extends where needed

#### âš™ï¸ `alu_top.sv`
- Performs all execution based on opcode and operands
- **Supports 30+ ALU operations**, including:
  - Arithmetic: `ADD`, `SUB`, `MUL`, `DIV`, `MOD`, `INC`, `DEC`
  - Logic: `AND`, `OR`, `XOR`, `NOT`, `NAND`, `NOR`, `XNOR`
  - Shifting/Rotating: `SHL`, `SHR`, `SAR`, `ROL`, `ROR`
  - Comparison: `EQ`, `NE`, `GT`, `LT`, `GE`, `LE`
  - Special: `MOV`, `NEG`, `ZERO`, `MAX`, `MIN`, `SWAP`, `REV`

#### ðŸ§® `register_file.sv`
- Implements 256 general-purpose registers (`32-bit` each)
- Dual write support per clock
- All values are fully accessible for output logging

---

### âœ… Phase 3: Processor Simulation and Execution

#### ðŸ§ª `processor_simulator.sv`
This module acts as the **top-level simulator** and drives the processor for instruction-by-instruction execution.

- Loads instructions from `output.txt`
- Decodes each instruction and triggers execution
- Updates the register file using ALU results
- Detects errors such as uninitialized register usage
- **Logs** every instruction and final result in human-readable format

> ðŸ”¹ Executes in **single-step mode** â€” ideal for debugging and understanding execution flow

---

## ðŸ“‚ Output Files

- `output.txt`: Machine code generated by the assembler
- `execution_log.txt`: Final decoded instructions and register output

---

## ðŸ“˜ Sample Log Output

```
Final Register Values:
R1 = 25
R2 = 10
----------------------------------------
Instruction 0: MOV R1 #25
MOV: R1 <- 25
Instruction 1: ADD R1 R2
ADD: R1 <- 25 + 10 = 35
```

---

## ðŸ§  Learning Outcome

- Understand how custom processors interpret instructions.
- Build and test a real instruction set with proper operand modes.
- Practice modular SystemVerilog design and simulation.
- Trace logic flow, debug and validate each instruction.
---

## ðŸ” Why This Project Stands Out

- âœ”ï¸ Modular, scalable architecture
- âœ”ï¸ 30+ ALU instructions with full mode support
- âœ”ï¸ Clear instruction log with decoding and result tracking
- âœ”ï¸ Professional structure â€” clean, synthesizable RTL
- âœ”ï¸ File-driven test environment (simulates real-world use cases)

## âœ… Summary

This project presents a **realistic, modular microprocessor implementation in SystemVerilog**, with full assembler and simulation support. Designed with industry practices and education in mind, it serves as an excellent showcase for:

